---
layout:     post
title:      G1垃圾回收器
subtitle:   可以控制STW时间的GC
date:       2019-07-31
author:     HH
header-img: img/post-bg-block.jpg
catalog: true
tags:
    - G1
    - STW
    - JVM
---

 # 简介

>G1垃圾回收器主要是把内存分为很多个小的region，回收的时候尽可能挑选停顿时间短以及回收对象最多的Region，尽量保证到达指定的垃圾回收系统停顿时间。

## G1对应的内存大小

```
-Xms 
-Xmx
-XX:G1HeapRegionSize   //HeapSize/2048或者指定
-XX:G1NewSizePercent  //5%
-XX:G1MaxNewSizePercent  //60%
```

## Region中的Eden和Survivor

```
-XX:SurvivorRatio:8
-XX:MaxGCPauseMills //200ms
```

## G1新生代的垃圾回收

对每个Region追踪回收时间，选择回收一部分Region。保证MaxGCPauseMills时间内被回收最多。

## 什么时候进入老年代

- 达到一定年龄 -XX:MaxTenuringThreshold

- 存活对象超过Survivor 50%

## 大对象

动态分配，不直接分配入老年代了。

## 新生代+老年代混合GC

```
-XX:InitiatingHeapOccupancyPercent //45%
```

意思是老年代占据堆内存45%的Region的时候，尝试混合回收。大概是接近1000个region。

## G1垃圾回收的过程

首先出发“初始标记”的操作，进入STW，仅标记GC Roots直接能引用的对象。这个过程很快。

#### 初始标记

如下图，先停止系统程序的运行，然后对各个线程内存中的局部变量代表的GC Roots，以及方法区中的类静态变量代表的GC Roots，进行扫描，标记出来他们直接引用的对象。

![初始标记](http://lemonhh.com/img/2019-07-31/1.png)

#### 并发标记

接着会进入“并发标记”的阶段，这个阶段允许系统程序的运行，同事进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，如下图所示。

![并发标记](http://lemonhh.com/img/2019-07-31/2.png)

这里对GC Roots追踪做更详细的说明，比如下面的代码：

```java
public class Kafka{
    public static ReplicaManager replicaManager = new ReplicaManager();
}
public class ReplicaManager{
    public ReplicaFetcher replicaFetcher = new ReplicaFetcher();
}
```

Kafka这个类有一个静态变量“replicaManager”，是一个GC Roots对象，初始标记阶段仅仅标记“replicaManager”的直接关联对象“ReplicaManager”。

然后并发标记阶段会进行GC Roots追踪，会从“replicaManager”的直接关联对象“ReplicaManager”开始往下追踪。可以看“ReplicaManager”有一个实例变量“replicaFetcher”，此时追踪“replicaFetcher”可以看到引用的“ReplicaFetcher”对象，那么此时这个“ReplicaFetcher”也要被标记为存活对象。

JVM会对并发标记阶段对对象作出一些修改记录，比如哪个对象被新建了，哪个失去了引用。

#### 最终标记

下个阶段最终标记阶段，这个阶段会进入STW，系统禁止运行，但是会根据并发标记阶段记录的对象修改，最终标记一下有哪些存活对象。

![最终标记](http://lemonhh.com/img/2019-07-31/3.png)

最后一个阶段就是混合回收的阶段，这个阶段会计算老年代中每个region的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。

接着会停止系统，然后尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我们指定的时间内。

#### 混合回收

比如老年代现在有1000个region都满了，但是因为根据预定目标，本次垃圾回收可能只能停顿200ms，通过之前的计算，800个region刚好要200ms，那么就只会回收800个Region。

> 这里涉及的参数+XX:MaxGCPauseMills

![指定时间内的垃圾回收](http://lemonhh.com/img/2019-07-31/4.png)

在老年堆占比达到45%的时候，触发的是“混合回收”，不仅仅会回收老年代，还有新生代和大对象。从这些区中各自挑选一些region，保证在MaxGCPauseMills中尽可能多的回收。

![混合回收](http://lemonhh.com/img/2019-07-31/5.png)

混合回收（MixedGC）可以执行多次，“-XX:G1MixedGCCountTarget”参数就是在一次混合回收的过程汇总，最后一个阶段执行几次混合回收，默认是8次。

假设一次混合回收预期要回收掉160个region，那么第一次混合回收会收掉一部分比如20个。

![第一个混合回收](http://lemonhh.com/img/2019-07-31/6.png)

如此反复执行8次就能把160个region全部回收，并且把系统停顿时间控制在指定范围内。这样可以在回收的间隙让系统正常运行一会。

还有一个参数就是“-XX:G1HeapWastePercent”,默认值是5%，他的意思是说在混合回收的时候，对Region的回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他的Region，然后找个Region中的垃圾对象全部清理掉。

![复制算法](http://lemonhh.com/img/2019-07-31/8.png)

这样的话在回收过程中就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立刻停止混合回收，意味这本次混合回收就结束了。

还有一个限制回收的条件即“-XX:G1MixedGCLiveThresholdPercent”，默认值是85%，意思是被回收region中的存活对象必须小于85%，大于85%复制算法的回收成本会很高。

#### 回收失败

在进行Mixed回收的时候，拷贝过程中如果没有空闲的region承载自己的存活对象，会触发一次失败。一旦失败就会停止系统程序，采用单线程标记、清理和压缩整理。

